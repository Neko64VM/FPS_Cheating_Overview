# 技術的仕様

## AI/Color AimBot
まずはメモリの読み書きを行う従来のチートではなく、「AI AimBot」や「Color AimBot」といったものについて取り扱う。  
これらは、第2章でも軽く触れたが画面上のデータを基にして動作している。
マウスの入力をArduinoやESP32といったマイコンを経由（マイコンでエイムアシスト分の差分を追加）させ、中間者攻撃のような手法を用いてアンチチートからの検出を逃れるものが主流。  
なお、あまりに人工的/不正確であるとサーバーサイドで検出される可能性があるとされている。

## 典型的なチート
現在主流となっているオートエイムやウォールハックといった機能を提供する一般的なチートは、基本的にゲームのメモリに対して読み取りや書き込みを行うことで動作しておりこれらも大きく2つの手法に分かれている。

## 内部チート
ゲームのプロセスに不正なDLLを挿入し、その内部でチートを実行する。  
ゲーム内関数のフックや呼び出しが可能である為外部チートと比べて比較的高度なことが可能であると同時に外部チートよりも高いパフォーマンスを発揮することができる。

## 外部チート
外部チートは、ゲームとは別の独立したプロセスとして動作するチートである。  
大まかに以下の4つに分類される。  

* ユーザーモード（Ring-3）
* カーネルモード（Ring-0）
* EFI
* DMA

どの領域からメモリを読み書きするかが大きな違い。  
ゲームの上に透明なウィンドウを配置してそこにESPやメニュー等のコンテンツをレンダリングするのが基本的な動作。また、既存の正規のオーバーレイウィンドウ（NVIDIA / AMD / Discord / OBS...）を乗っ取りそこにレンダリングを行うものも存在する。

### EFI
正直これに関しては触れてもないし詳しくは調べてはいないですが、OSが起動する前にいろいろEFI空間に読み込ませてそこからメモリを読み取る感じです。

### DMA (Direct Memory Access) について
DMAとはその名の通り、メモリに直接アクセスしてそこから必要なデータを読み取りチートを動作させる手法。

ゲームを実行するPCに専用のPCIディバイスを取り付け、2台目のPCで読み取ったデータをESPや2Dレーダーとして処理するものが主流である。  
DMAに使用するPCIディバイス（以下DMAカード）自体は数万円程度の価格で販売されており、2台目のPCも用意することを考えると初期投資にそれなりの費用が必要である。  
ただし、DMAカードのファームウェアを正規のNICやサウンドカード、キャプチャーボードのようなディバイスに偽装することによりアンチチートの検出から逃れることが可能とされており、他のチートと比べると現段階では比較的安全性が高い傾向にある。

#### ToDo
ここの画像用意する

ゲームを動かすPC①のRAM上からDMAカードで対象となる領域を読み取り、PC②でDMAカードから送られてくる情報を視覚化する。  
画像の場合、Map Radarと呼ばれるものを使用している。  

#### KVM-DMA
KVM上で動作する仮想マシン（VM）のメモリをホスト側から読み取るものであり、DMAの一種である。  
この手法を利用するにあたり、LinuxやKVM/QEMUといった前提知識に加えGPUパススルー、対応するチートが販売されている訳も無いのでチートを自作できる能力 といった比較的高度な知識が複数要求される為、導入や使用のハードルが非常に高い。  
また、KVM-DMAに関しては仕様上どのようなアンチチートでもVMの外からメモリの読み書きが行われていること自体を検出することが極めて困難であるが、セットアップが煩雑な上に根本的にVMでのプレイを禁止することが非常に有効な対策となる為、脅威としては相当に限定的であると思われる。

## 各種機能の実装
### ESP
1. 敵のVector3 (X, Y, Z)座標を取得
2. 敵の座標データを、画面上の座標 Vector2 (X, Y) に変換。WorldToScreenという。
3. 変換後の画面座標にESP BoxやHP、距離 名前等のやつをレンダリング。

### AimBot
#### メモリに書き込むやつ
1. 敵のVector3 (X, Y, Z)座標を取得
2. どの程度プレイヤーの視点を動かせば敵にエイムが合うかを計算
3. 算出された値をプレイヤーの視点情報を格納するアドレスに書き込む 

ゲームエンジンによるので詳しくは割愛するが、SilentAimも似たような感じ。  

#### マウスベースのやつ
1. 敵のVector3 (X, Y, Z)座標を取得
2. 敵の座標データを、画面上の座標 Vector2 (X, Y) に変換。
3. mouse_event / SendInput等の関数を用いてそこにマウスを動かす。

### SiletAim
エンジンや実装方法によるので一概にこうであると説明することはできない。  
しかし、SourceEngine（Counter-Strike/Apex等）であれば

1. サーバーに偽の視点情報を送信（UserCMD）
2. サーバー側で検証、クライアントにヒット判定を返す
3. クライアント側でエイムが合っていないにも関わらずヒット判定が出る

といったものがSilentAim実装手法の1つとして存在する。